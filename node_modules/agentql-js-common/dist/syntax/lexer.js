"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lexer = void 0;
const errors_1 = require("../errors");
const character_utils_1 = require("./character-utils");
const token_1 = require("./token");
const token_kind_1 = require("./token-kind");
class Lexer {
    constructor(source) {
        const startOfFileToken = new token_1.Token(token_kind_1.TokenKind.SOF, 0, 0, 1, 0);
        this.source = source;
        this.token = startOfFileToken;
        this.lastToken = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
    }
    advance() {
        this.lastToken = this.token;
        this.token = this.lookahead();
        return this.token;
    }
    lookahead() {
        let token = this.token;
        let endOfFile = false;
        while (!endOfFile) {
            if (token.kind === token_kind_1.TokenKind.EOF) {
                endOfFile = true;
            }
            if (token.next) {
                token = token.next;
            }
            else {
                const nextToken = this.readNextToken(token.end);
                token.next = nextToken;
                nextToken.prev = token;
                token = nextToken;
            }
            if (!this.isIgnoredToken(token.kind)) {
                break;
            }
        }
        return token;
    }
    isIgnoredToken(kind) {
        return kind === token_kind_1.TokenKind.NEWLINE;
    }
    readNextToken(start) {
        const body = this.source.body;
        const bodyLength = body.length;
        let position = start;
        while (position < bodyLength) {
            const code = body.charCodeAt(position);
            if (code === 32 || code === 9) {
                // space, tab
                position += 1;
                continue;
            }
            if (code === 13) {
                // carriage return \r
                if (body.charCodeAt(position + 1) === 10) {
                    position += 2;
                }
                else {
                    position += 1;
                }
                this.line += 1;
                this.lineStart = position;
                continue;
            }
            if (code === 10) {
                // new line \n
                const tokenToReturn = this.createToken(token_kind_1.TokenKind.NEWLINE, start, position + 1);
                // Update line and lineStart after creating the token
                this.line += 1;
                this.lineStart = position;
                return tokenToReturn;
            }
            if (code === 44) {
                // ,
                return this.createToken(token_kind_1.TokenKind.COMMA, start, position + 1);
            }
            if (code === 123) {
                // {
                return this.createToken(token_kind_1.TokenKind.BRACE_L, start, position + 1);
            }
            if (code === 125) {
                // }
                return this.createToken(token_kind_1.TokenKind.BRACE_R, start, position + 1);
            }
            if (code === 91) {
                // [
                return this.createToken(token_kind_1.TokenKind.BRACKET_L, start, position + 1);
            }
            if (code === 93) {
                // ]
                return this.createToken(token_kind_1.TokenKind.BRACKET_R, start, position + 1);
            }
            if ((0, character_utils_1.isDescriptionStart)(code)) {
                return this.readDescription(position);
            }
            if ((0, character_utils_1.isIdentifierStart)(code)) {
                return this.readName(position);
            }
            throw new errors_1.QuerySyntaxError(null, body[position], this.line, position - this.lineStart + 1);
        }
        return this.createToken(token_kind_1.TokenKind.EOF, bodyLength, bodyLength);
    }
    createToken(kind, start, end, value = null) {
        const line = this.line;
        const column = start - this.lineStart + 1;
        return new token_1.Token(kind, start, end, line, column, value);
    }
    readName(start) {
        let position = start + 1;
        const body = this.source.body;
        const bodyLength = body.length;
        while (position < bodyLength) {
            const code = body.charCodeAt(position);
            if (!(0, character_utils_1.isIdentifierContinue)(code)) {
                break;
            }
            position++;
        }
        return this.createToken(token_kind_1.TokenKind.IDENTIFIER, start, position, body.slice(start, position));
    }
    readDescription(start) {
        let position = start + 1; // Skip the opening paren
        let openParenCount = 1; // Initialise to 1 to account for the opening paren
        const body = this.source.body;
        const bodyLength = body.length;
        while (position < bodyLength) {
            const code = body.charCodeAt(position);
            if (code === 40) {
                // (
                openParenCount++;
            }
            else if (code === 41) {
                // )
                openParenCount--;
                if (!openParenCount) {
                    position++;
                    break;
                }
            }
            else if (!(0, character_utils_1.isDescriptionContinue)(code)) {
                throw new errors_1.QuerySyntaxError(null, body[position], this.line, position - this.lineStart + 1);
            }
            position++;
        }
        const value = this.unwrapDescription(body.slice(start, position));
        return this.createToken(token_kind_1.TokenKind.DESCRIPTION, start, position, value);
    }
    unwrapDescription(description) {
        if (description.length === 2) {
            return ''; // Empty description
        }
        description = description.slice(1, description.length - 1); // Remove the opening and closing paren
        let left = 0;
        let right = description.length - 1;
        let isWrapper = true;
        while (isWrapper) {
            if (description[left] !== description[right]) {
                isWrapper = false;
            }
            else if (description[left] === '"' && description[right] === '"') {
                left++;
                right--;
            }
            else if (description[left] === "'" && description[right] === "'") {
                left++;
                right--;
            }
            else {
                isWrapper = false;
            }
        }
        return description.slice(left, right + 1);
    }
}
exports.Lexer = Lexer;
