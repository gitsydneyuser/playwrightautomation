"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryParser = void 0;
const errors_1 = require("../errors");
const lexer_1 = require("./lexer");
const node_1 = require("./node");
const source_1 = require("./source");
const token_kind_1 = require("./token-kind");
class QueryParser {
    constructor(source) {
        this.source = source instanceof source_1.Source ? source : new source_1.Source(source);
        this.lexer = new lexer_1.Lexer(this.source);
    }
    parse() {
        this.expectToken(token_kind_1.TokenKind.SOF);
        const node = this.parseContainer();
        this.expectToken(token_kind_1.TokenKind.EOF);
        return node;
    }
    parseContainer(name = '', description = null) {
        const nodes = this.many(token_kind_1.TokenKind.BRACE_L, this.parseNode.bind(this), token_kind_1.TokenKind.BRACE_R);
        return new node_1.ContainerNode(name, description, nodes);
    }
    parseNode() {
        const token = this.expectToken(token_kind_1.TokenKind.IDENTIFIER);
        const name = token.value;
        if (!name) {
            throw new errors_1.QuerySyntaxError("name can't be empty", token.kind, token.line, token.column);
        }
        let description = null;
        if (this.peek(token_kind_1.TokenKind.DESCRIPTION)) {
            description = this.expectToken(token_kind_1.TokenKind.DESCRIPTION).value;
        }
        let node;
        if (this.peek(token_kind_1.TokenKind.BRACE_L)) {
            node = this.parseContainer(name, description);
        }
        else if (this.peek(token_kind_1.TokenKind.BRACKET_L)) {
            node = this.parseList(name, description);
        }
        else {
            node = new node_1.IdNode(name, description);
        }
        return node;
    }
    parseList(name, description) {
        const preToken = this.lexer.token.prev;
        if ((preToken === null || preToken === void 0 ? void 0 : preToken.kind) != token_kind_1.TokenKind.IDENTIFIER && (preToken === null || preToken === void 0 ? void 0 : preToken.kind) != token_kind_1.TokenKind.DESCRIPTION) {
            const message = `Expected Identifier or Description, found ${preToken === null || preToken === void 0 ? void 0 : preToken.kind} on row ${preToken === null || preToken === void 0 ? void 0 : preToken.line}. List token ([]) must follow an identifier or description.`;
            throw new errors_1.QuerySyntaxError(message, (preToken === null || preToken === void 0 ? void 0 : preToken.kind) || '', (preToken === null || preToken === void 0 ? void 0 : preToken.line) || 0, (preToken === null || preToken === void 0 ? void 0 : preToken.column) || 0);
        }
        this.expectToken(token_kind_1.TokenKind.BRACKET_L);
        this.expectToken(token_kind_1.TokenKind.BRACKET_R);
        let node;
        if (this.peek(token_kind_1.TokenKind.BRACE_L)) {
            const container = this.parseContainer(name, description);
            node = new node_1.ContainerListNode(container.name, description, container.children);
        }
        else {
            node = new node_1.IdListNode(name, description);
        }
        return node;
    }
    many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const identifierNameSet = new Set();
        const nodes = [];
        let foundCloseKind = false;
        while (!foundCloseKind) {
            // Ensure no duplicate identifiers in the same container
            if (this.peek(token_kind_1.TokenKind.IDENTIFIER)) {
                const identifier = this.lexer.token.value;
                if (identifier) {
                    if (identifierNameSet.has(identifier)) {
                        const errorMessage = `Duplicate identifier '${identifier}' on row ${this.lexer.token.line}. Identifier must be unique in the same container.`;
                        throw new errors_1.QuerySyntaxError(errorMessage, identifier, this.lexer.token.line, this.lexer.token.column);
                    }
                    identifierNameSet.add(identifier);
                }
            }
            const node = parseFn();
            nodes.push(node);
            if (this.peek(token_kind_1.TokenKind.COMMA)) {
                this.lexer.advance();
            }
            if (this.peek(closeKind)) {
                this.lexer.advance();
                foundCloseKind = true;
            }
        }
        return nodes;
    }
    expectToken(kind) {
        const token = this.lexer.token;
        if (token.kind === kind) {
            this.lexer.advance();
            return token;
        }
        const message = `Expected ${kind}, found ${token.kind} on row ${token.line}`;
        throw new errors_1.QuerySyntaxError(message, token.kind, token.line, token.column);
    }
    peek(kind) {
        return this.lexer.token.kind === kind;
    }
}
exports.QueryParser = QueryParser;
