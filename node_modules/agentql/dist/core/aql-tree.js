"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aqlGenATree = aqlGenATree;
const errors_1 = require("./errors");
const logger_1 = require("./logger");
// generate the accessibility tree of a page and (optional) its iframes
function aqlGenATree(context, lastUsedId, includeHidden, fnProcessFrame, fnSetIFramePath, fnGetChildFrameContext) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield _genATreeRecursively(context, lastUsedId, '', includeHidden, fnProcessFrame, fnSetIFramePath, fnGetChildFrameContext);
        return result;
    });
}
function _genATreeRecursively(context, lastUsedId, iframePath, includeHidden, fnProcessFrame, fnSetIFramePath, fnGetIFrameContext) {
    return __awaiter(this, void 0, void 0, function* () {
        // process current frame, which is the main frame or an nested iframe
        let result;
        try {
            result = yield fnProcessFrame(context, lastUsedId, iframePath, includeHidden);
        }
        catch (e) {
            logger_1.logger.error(`Failed to process frame (${iframePath}):`, e);
            throw new errors_1.AccessibilityTreeError();
        }
        lastUsedId = result.lastUsedId;
        const atree = result.atree;
        const iframeIds = result.iframeIds;
        // Process all children iframes of the current frame
        if (fnGetIFrameContext && iframeIds) {
            for (let i = 0; i < iframeIds.length; i++) {
                const iframeId = iframeIds[i];
                const iframeContext = yield fnGetIFrameContext(context, iframeId);
                if (!iframeContext) {
                    continue;
                }
                const iframePathToSend = iframePath === '' ? iframeId : iframePath + '.' + iframeId;
                yield fnSetIFramePath(iframeContext, iframePathToSend);
                // recursively process the child iframe
                const iframeResult = yield _genATreeRecursively(iframeContext, lastUsedId, iframePathToSend, includeHidden, fnProcessFrame, fnSetIFramePath, fnGetIFrameContext);
                if (!iframeResult ||
                    !iframeResult.atree ||
                    !result.lastUsedId ||
                    iframeResult.lastUsedId < lastUsedId) {
                    logger_1.logger.warning(`Failed to process iframe(${iframePathToSend}), skip.`);
                    continue;
                }
                const iframeTree = iframeResult.atree;
                lastUsedId = iframeResult.lastUsedId;
                // append the iframe to the atree
                const iframeNode = _locateIframeNode(atree, iframeId);
                if (!iframeNode) {
                    // could happen if the iframe hidden.
                    logger_1.logger.debug(`Failed to locate child iframe node for iframe: iframeId=(${iframeId}), skip.`);
                    continue;
                }
                if (!iframeNode.children) {
                    iframeNode.children = [];
                }
                iframeNode.children.push(iframeTree);
            }
        }
        // clean up empty children
        _deleteEmptyChildren(atree);
        return {
            atree: atree,
            lastUsedId: lastUsedId,
        };
    });
}
function _locateIframeNode(atree, iframeId) {
    if (!atree) {
        return null;
    }
    if (atree.attributes.tf623_id === iframeId) {
        return atree;
    }
    if (!atree.children) {
        return null;
    }
    for (let i = 0; i < atree.children.length; i++) {
        const iframeNode = _locateIframeNode(atree.children[i], iframeId);
        if (iframeNode) {
            return iframeNode;
        }
    }
    return null;
}
function _deleteEmptyChildren(atree) {
    if (!atree || !atree.children) {
        return;
    }
    if (typeof atree.children === 'string') {
        try {
            atree.children = JSON.parse(atree.children);
        }
        catch (e) {
            logger_1.logger.error(`Accessibility tree contains children of str type and is not a valid JSON string: ${e}`);
            throw new errors_1.AccessibilityTreeError();
        }
    }
    if (Array.isArray(atree.children)) {
        for (let i = 0; i < atree.children.length; i++) {
            _deleteEmptyChildren(atree.children[i]);
        }
        if (atree.children.length === 0) {
            delete atree.children;
        }
    }
}
