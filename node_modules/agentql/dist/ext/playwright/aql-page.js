"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrap = wrap;
const agentql_js_common_1 = require("agentql-js-common");
const errors_1 = require("../../core/errors");
const logger_1 = require("../../core/logger");
const aql_locator_1 = require("./aql-locator");
const aql_response_proxy_1 = require("./aql-response-proxy");
const constants_1 = require("./constants");
const driver_1 = require("./driver");
const page_monitor_1 = require("./page-monitor");
const utils_1 = require("./utils");
/**
 * Casts a Playwright `Page` object to an AgentQL `Page` type to get access to the AgentQL's querying API.
 *
 * @param {Page} page - The Playwright Page object to be wrapped.
 * @returns {PageExt} The wrapped Page object with AgentQL extensions.
 */
function wrap(page) {
    return __awaiter(this, void 0, void 0, function* () {
        page.on('crash', utils_1.handlePageCrash);
        const originalGoto = page.goto;
        let monitor = null;
        let lastQuery = null;
        let lastResponse = null;
        let lastAccessibilityTree = null;
        if (monitor === null) {
            monitor = new page_monitor_1.PageActivityMonitor(page);
            monitor.start();
        }
        yield monitor.monitorDomChange();
        return Object.assign(page, {
            getLastQuery() {
                return __awaiter(this, void 0, void 0, function* () {
                    return lastQuery;
                });
            },
            getLastResponse() {
                return __awaiter(this, void 0, void 0, function* () {
                    return lastResponse;
                });
            },
            getLastAccessibilityTree() {
                return __awaiter(this, void 0, void 0, function* () {
                    return lastAccessibilityTree;
                });
            },
            goto(url, options) {
                return __awaiter(this, void 0, void 0, function* () {
                    logger_1.logger.debug(`Navigating to URL: ${url} with options: ${JSON.stringify(options)}...`);
                    if (!options) {
                        options = {};
                    }
                    if (!options.waitUntil) {
                        options.waitUntil = 'domcontentloaded';
                    }
                    const result = yield originalGoto.call(page, url, options);
                    monitor.monitorDomChange();
                    logger_1.logger.debug(`Navigation to URL: ${url} completed.`);
                    return result;
                });
            },
            getByPrompt(prompt, options) {
                return __awaiter(this, void 0, void 0, function* () {
                    const { timeout = constants_1.DEFAULT_QUERY_ELEMENTS_TIMEOUT_MS, waitForNetworkIdle = constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE, includeHidden = constants_1.DEFAULT_INCLUDE_HIDDEN_ELEMENTS, mode = constants_1.DEFAULT_RESPONSE_MODE, } = options || {};
                    logger_1.logger.debug(`Getting element by prompt: ${prompt}...`);
                    yield this.waitForPageReadyState({ waitForNetworkIdle });
                    const { response, atree, query } = yield (0, driver_1.pwGetByPrompt)(page, prompt, timeout, includeHidden, mode);
                    const element = response.page_element;
                    if (!element) {
                        logger_1.logger.debug(`No element found for prompt: ${prompt}.`);
                        return null;
                    }
                    const locator = yield (0, driver_1.pwLocateInteractiveElement)(page, element);
                    if (!locator) {
                        logger_1.logger.debug(`No locator found for element with prompt: ${prompt}.`);
                        return null;
                    }
                    this._setDebugInfo(query, response, JSON.stringify(atree));
                    logger_1.logger.debug(`Element found for prompt: ${prompt}.`);
                    return (0, aql_locator_1.wrapLocator)(locator, element);
                });
            },
            queryElements(query, options) {
                return __awaiter(this, void 0, void 0, function* () {
                    const { timeout = constants_1.DEFAULT_QUERY_ELEMENTS_TIMEOUT_MS, waitForNetworkIdle = constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE, includeHidden = constants_1.DEFAULT_INCLUDE_HIDDEN_ELEMENTS, mode = constants_1.DEFAULT_RESPONSE_MODE, } = options || {};
                    logger_1.logger.debug(`Querying elements with query: ${(0, logger_1.minifyQuery)(query)}...`);
                    const queryNode = new agentql_js_common_1.QueryParser(query).parse();
                    yield this.waitForPageReadyState({ waitForNetworkIdle });
                    const { response, atree } = yield (0, driver_1.pwQueryElements)(page, query, timeout, includeHidden, mode);
                    const locators = yield (0, aql_locator_1.generateResponseWithLocatorExt)(page, response, queryNode);
                    this._setDebugInfo(query, response, JSON.stringify(atree));
                    logger_1.logger.debug(`Query for elements completed: ${(0, logger_1.minifyQuery)(query)}.`);
                    return new aql_response_proxy_1.AQLResponseProxy(locators, queryNode);
                });
            },
            queryData(query, options) {
                return __awaiter(this, void 0, void 0, function* () {
                    const { timeout = constants_1.DEFAULT_QUERY_DATA_TIMEOUT_MS, waitForNetworkIdle = constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE, includeHidden = constants_1.DEFAULT_INCLUDE_HIDDEN_DATA, mode = constants_1.DEFAULT_RESPONSE_MODE, } = options || {};
                    logger_1.logger.debug(`Querying data with query: ${(0, logger_1.minifyQuery)(query)}...`);
                    new agentql_js_common_1.QueryParser(query).parse();
                    yield this.waitForPageReadyState({ waitForNetworkIdle });
                    const { response, atree } = yield (0, driver_1.pwQueryData)(page, query, timeout, includeHidden, mode);
                    this._setDebugInfo(query, response, JSON.stringify(atree));
                    logger_1.logger.debug(`Query for data completed: ${(0, logger_1.minifyQuery)(query)}.`);
                    return response;
                });
            },
            waitForPageReadyState(options) {
                return __awaiter(this, void 0, void 0, function* () {
                    const { waitForNetworkIdle = constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE } = options || {};
                    logger_1.logger.debug(`Waiting for page to reach 'Page Ready' state...`);
                    if (!waitForNetworkIdle) {
                        // If we don't need to wait for network idle, we can return early and not start the monitor.
                        // We have overridden the page.goto method to wait for "domcontentloaded" already.
                        logger_1.logger.debug('Page ready: "load" event caught.');
                        return;
                    }
                    if (monitor === null) {
                        throw new errors_1.PageMonitorNotInitializedError();
                    }
                    yield (0, utils_1.determineLoadState)(page, monitor);
                    monitor.reset();
                });
            },
            _setDebugInfo(query, response, accessibilityTree) {
                lastQuery = query;
                lastResponse = response;
                lastAccessibilityTree = accessibilityTree;
            },
        });
    });
}
