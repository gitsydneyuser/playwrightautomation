"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NETWORK_QUIET_OR_MULTIPLE_REQUESTS_THRESHOLD_MS = exports.NETWORK_QUIET_THRESHOLD_MS = exports.DOM_NETWORK_QUIET_THRESHOLD_MS = exports.PageActivityMonitor = void 0;
const snippet_loader_1 = require("../../core/js-snippets/snippet-loader");
const logger_1 = require("../../core/logger");
const DOM_NETWORK_QUIET_THRESHOLD_MS = 500;
exports.DOM_NETWORK_QUIET_THRESHOLD_MS = DOM_NETWORK_QUIET_THRESHOLD_MS;
const NETWORK_QUIET_THRESHOLD_MS = 1500;
exports.NETWORK_QUIET_THRESHOLD_MS = NETWORK_QUIET_THRESHOLD_MS;
const NETWORK_QUIET_OR_MULTIPLE_REQUESTS_THRESHOLD_MS = 6000;
exports.NETWORK_QUIET_OR_MULTIPLE_REQUESTS_THRESHOLD_MS = NETWORK_QUIET_OR_MULTIPLE_REQUESTS_THRESHOLD_MS;
class PageActivityMonitor {
    constructor(page) {
        this.requestLog = new Map();
        this.responseLog = new Set();
        this.lastNetworkActivityTime = 0;
        this.multipleRequestFound = false;
        this.multipleRequestUrl = '';
        this.pageLoaded = false;
        this.page = page;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            this.page.on('request', this.onRequest.bind(this));
            this.page.on('requestfinished', this.onResponse.bind(this));
            this.page.on('requestfailed', this.onResponse.bind(this));
            this.page.on('load', this.onLoad.bind(this));
        });
    }
    monitorDomChange() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.page.evaluate(yield (0, snippet_loader_1.loadJS)('add-dom-change-listener'));
        });
    }
    reset() {
        this.lastNetworkActivityTime = Date.now();
        this.multipleRequestFound = false;
        this.multipleRequestUrl = '';
        this.requestLog.clear();
        this.responseLog.clear();
        this.pageLoaded = false;
    }
    onRequest(request) {
        const url = request.url();
        this.lastNetworkActivityTime = Date.now();
        // Start logging duplicate urls after the first 6 seconds
        if (!this.multipleRequestFound) {
            if (this.requestLog.has(url)) {
                this.multipleRequestFound = true;
                this.multipleRequestUrl = url;
            }
        }
        // log this request
        this.requestLog.set(url, this.lastNetworkActivityTime);
    }
    onResponse(request) {
        const url = request.url();
        this.lastNetworkActivityTime = Date.now();
        if (this.requestLog.has(url)) {
            this.responseLog.add(url);
        }
    }
    onLoad() {
        this.pageLoaded = true;
    }
    getLoadStatus() {
        return this.pageLoaded;
    }
    isPageReady(startTime, lastActiveDomTime) {
        const currentTime = Date.now();
        let isDomQuiet = false;
        let isNetworkQuiet = false;
        // check if DOM has changed
        if (lastActiveDomTime) {
            isDomQuiet = currentTime - lastActiveDomTime > DOM_NETWORK_QUIET_THRESHOLD_MS;
        }
        // check for inactivity
        const missingResponses = [];
        if (currentTime - this.lastNetworkActivityTime > DOM_NETWORK_QUIET_THRESHOLD_MS) {
            this.requestLog.forEach((_, url) => {
                if (!this.responseLog.has(url)) {
                    missingResponses.push(url);
                }
            });
            // If not all requests have been resolved,
            // check if 1.5 seconds have passed since the last request.
            // If so, treat the request as resolved
            let missingResponseCount = missingResponses.length;
            for (const missingResponse in missingResponses) {
                // "|| 0" to make typescript happy, but this should never happen
                const timeDiff = currentTime - (this.requestLog.get(missingResponse) || 0);
                if (timeDiff > NETWORK_QUIET_THRESHOLD_MS) {
                    missingResponseCount--;
                }
            }
            if (missingResponseCount === 0) {
                if (isDomQuiet) {
                    logger_1.logger.debug(`Page ready: No network and DOM activity detected for ${DOM_NETWORK_QUIET_THRESHOLD_MS} milliseconds`);
                    return true;
                }
                isNetworkQuiet = true;
            }
        }
        // If 6 seconds has passed, only check if the network is quiet or if multiple requests to the same destination are found
        if (currentTime - startTime > NETWORK_QUIET_OR_MULTIPLE_REQUESTS_THRESHOLD_MS) {
            if (isNetworkQuiet) {
                logger_1.logger.debug(`Page ready: No network activity detected for ${DOM_NETWORK_QUIET_THRESHOLD_MS} milliseconds`);
                return true;
            }
            if (this.multipleRequestFound) {
                logger_1.logger.debug(`Page ready: Multiple outgoing requests to url ${this.multipleRequestUrl} are found`);
                return true;
            }
        }
        return false;
    }
}
exports.PageActivityMonitor = PageActivityMonitor;
