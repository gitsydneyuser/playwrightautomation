"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineLoadState = determineLoadState;
exports.handlePageCrash = handlePageCrash;
const errors_1 = require("../../core/errors");
const snippet_loader_1 = require("../../core/js-snippets/snippet-loader");
const logger_1 = require("../../core/logger");
const driver_constants_1 = require("./driver-constants");
const waitFor = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
function determineLoadState(page_1, monitor_1) {
    return __awaiter(this, arguments, void 0, function* (page, monitor, timeout = driver_constants_1.SLOWEST_WEBSITE_AVG_LOAD_TIME_MS) {
        const startTime = Date.now();
        let isPageReady = false;
        while (!isPageReady) {
            let lastUpdatedTime = startTime;
            try {
                lastUpdatedTime = yield page.evaluate(yield (0, snippet_loader_1.loadJS)('get-last-dom-change'));
            }
            catch (_a) {
                // If the page is navigating, the evaluate function will raise an error.
                // In this case, we wait for the page to load.
                let pageConsideredLoaded = false;
                while (!pageConsideredLoaded) {
                    if (monitor.getLoadStatus() || Date.now() - startTime > driver_constants_1.WEBSITE_AVG_LOAD_TIME_MS) {
                        pageConsideredLoaded = true;
                    }
                    yield waitFor(200);
                }
                lastUpdatedTime = Date.now();
            }
            if (monitor.isPageReady(startTime, lastUpdatedTime)) {
                isPageReady = true;
            }
            if (Date.now() - startTime > timeout) {
                logger_1.logger.warning('Page ready: Timeout while waiting for page to settle.');
                isPageReady = true;
            }
            yield waitFor(100);
        }
    });
}
function handlePageCrash(page) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.logger.error(`Page crashed: ${yield page.url()}`);
        yield page.close();
        throw new errors_1.PageCrashError(yield page.url());
    });
}
