"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserAgentPreset = exports.BrowserSession = void 0;
exports.createBrowserSession = createBrowserSession;
const axios_1 = require("axios");
const api_constants_1 = require("../core/api-constants");
const errors_1 = require("../core/errors");
const logger_1 = require("../core/logger");
const utils_1 = require("../core/utils");
/**
 * User Agent presets for different operating systems.
 * By selecting specific preset underlying remote browser will mimic user agent of the selected operating system modifying HTTP headers, navigator object and more.
 */
var UserAgentPreset;
(function (UserAgentPreset) {
    UserAgentPreset["WINDOWS"] = "windows";
    UserAgentPreset["MACOS"] = "macos";
    UserAgentPreset["LINUX"] = "linux";
})(UserAgentPreset || (exports.UserAgentPreset = UserAgentPreset = {}));
/**
 * Create a new remote browser session via Tetra.
 *
 * @param uaPreset - User Agent preset (windows, macos, linux). Optional.
 * @returns A BrowserSession object with cdpUrl property for connecting to the browser
 * @throws APIKeyError if the API key is not set or invalid
 * @throws Error if the API request fails
 */
function createBrowserSession(uaPreset) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const apiKey = (0, utils_1.getApiKey)();
        const url = `${api_constants_1.SERVICE_URL}${api_constants_1.BROWSER_SESSIONS_ENDPOINT}`;
        const headers = { 'X-API-Key': apiKey };
        // Prepare request body
        const body = {};
        if (uaPreset) {
            body.browser_ua_preset = uaPreset;
        }
        try {
            const response = yield axios_1.default.post(url, body, { headers });
            const sessionData = response.data;
            const browserSession = new BrowserSession(sessionData);
            logger_1.logger.info(`Successfully allocated browser session: ${browserSession.cdpUrl}`);
            return browserSession;
        }
        catch (error) {
            if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 401) {
                throw new errors_1.APIKeyError('Invalid or expired API key provided.');
            }
            logger_1.logger.error(`Failed to allocate browser session: ${error.message}`);
            throw new Error(`Failed to create browser session: ${error.message}`);
        }
    });
}
/**
 * Represents an allocated browser session with CDP connection details.
 */
class BrowserSession {
    /**
     * Initialize BrowserSession with session data from the API.
     *
     * @param sessionData - Raw session data returned from the browser allocation API
     * @throws Error if required fields are missing from sessionData
     */
    constructor(sessionData) {
        const requiredFields = ['cdp_url', 'base_url'];
        const invalidFields = requiredFields.reduce((acc, field) => {
            if (!(field in sessionData))
                acc.missing.push(field);
            else if (!sessionData[field])
                acc.empty.push(field);
            return acc;
        }, { missing: [], empty: [] });
        if (invalidFields.missing.length > 0) {
            throw new Error(`Missing required fields in session_data: ${invalidFields.missing.join(', ')}`);
        }
        if (invalidFields.empty.length > 0) {
            throw new Error(`Required fields cannot be empty: ${invalidFields.empty.join(', ')}`);
        }
        this._cdpUrl = sessionData['cdp_url'];
        this._baseUrl = sessionData['base_url'];
    }
    /**
     * Get the Chrome DevTools Protocol URL for connecting to the browser.
     *
     * @returns The CDP URL for browser connection
     */
    get cdpUrl() {
        return this._cdpUrl;
    }
    /**
     * Get the page streaming URL for a specific page number.
     *
     * @param pageNum - The page number to get the streaming URL for
     * @returns The streaming URL for the specified page
     */
    getPageStreamingUrl(pageNum) {
        if (pageNum < 0) {
            throw new Error('Page number must be non-negative');
        }
        return `${this._baseUrl}/stream/${pageNum}`;
    }
}
exports.BrowserSession = BrowserSession;
